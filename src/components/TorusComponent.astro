---
// è¿™é‡Œä¸éœ€è¦æœåŠ¡ç«¯ä»£ç 
---

<!-- 3Dåœºæ™¯å®¹å™¨ -->
<div id="torus-container" style="width: 100%; height: 100vh;"></div>

<!-- Vision Proé£æ ¼æ§åˆ¶é¢æ¿ -->
<div id="control-panel" style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 1000;">
  
  <!-- æ¨¡å‹æ§åˆ¶èœå• -->
  <div class="vision-menu" id="model-menu-container" style="margin-bottom: 15px;">
    <div class="menu-header" data-menu="model">
      <span class="menu-title">æ¨¡å‹</span>
      <span class="menu-toggle">â–¼</span>
    </div>
    <div class="menu-content">
      <div class="button-group">
        <button class="control-btn active" data-model="torus" data-tooltip="åœ†ç¯">ğŸ©</button>
        <button class="control-btn" data-model="sphere" data-tooltip="çƒä½“">ğŸ”®</button>
        <button class="control-btn" data-model="cube" data-tooltip="ç«‹æ–¹ä½“">ğŸ“¦</button>
        <button class="control-btn" data-model="cone" data-tooltip="åœ†é”¥">ğŸ”º</button>
        <button class="control-btn" data-model="cylinder" data-tooltip="åœ†æŸ±">ğŸ¥«</button>
      </div>
    </div>
  </div>

  <!-- æè´¨æ§åˆ¶èœå• -->
  <div class="vision-menu" id="material-menu-container">
    <div class="menu-header" data-menu="material">
      <span class="menu-title">æè´¨</span>
      <span class="menu-toggle">â–¼</span>
    </div>
    <div class="menu-content">
      <div class="button-group">
        <button class="control-btn active" data-material="chrome" data-tooltip="é“¬åˆé‡‘">âœ¨</button>
        <button class="control-btn" data-material="gold" data-tooltip="é»„é‡‘">ğŸ‘‘</button>
        <button class="control-btn" data-material="copper" data-tooltip="é“œ">ğŸ”¶</button>
        <button class="control-btn" data-material="emerald" data-tooltip="ç¿¡ç¿ ">ğŸ’š</button>
        <button class="control-btn" data-material="ruby" data-tooltip="çº¢å®çŸ³">â¤ï¸</button>
        <button class="control-btn" data-material="sapphire" data-tooltip="è“å®çŸ³">ğŸ’™</button>
      </div>
    </div>
  </div>

</div>

<!-- Vision Pro UI æ ·å¼ -->
<style>
  /* Vision Pro æ¯›ç»ç’ƒæ•ˆæœ */
  .vision-menu {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    padding: 0;
    min-width: 280px;
    box-shadow: 
      0 8px 32px rgba(0, 0, 0, 0.3),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
  }

  .vision-menu:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
  }

  .menu-header {
    padding: 12px 20px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(255, 255, 255, 0.05);
    transition: background 0.2s ease;
  }

  .menu-header:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .menu-title {
    color: rgba(255, 255, 255, 0.9);
    font-size: 14px;
    font-weight: 500;
    letter-spacing: 0.5px;
  }

  .menu-toggle {
    color: rgba(255, 255, 255, 0.7);
    font-size: 12px;
    transition: transform 0.3s ease;
  }

  .menu-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .menu-content.expanded {
    max-height: 100px;
    padding: 15px 20px;
  }

  .button-group {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .control-btn {
    width: 44px;
    height: 44px;
    border: none;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.15);
    color: rgba(255, 255, 255, 0.9);
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .control-btn:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: scale(1.05);
  }

  .control-btn.active {
    background: rgba(76, 175, 80, 0.8);
    box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
  }

  .control-btn.active:hover {
    background: rgba(76, 175, 80, 0.9);
  }

  /* å·¥å…·æç¤º */
  .control-btn::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 5px 10px;
    border-radius: 6px;
    font-size: 11px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    margin-bottom: 5px;
  }

  .control-btn:hover::after {
    opacity: 1;
  }

  /* å“åº”å¼è®¾è®¡ */
  @media (max-width: 600px) {
    .vision-menu {
      min-width: 240px;
    }
    
    .control-btn {
      width: 38px;
      height: 38px;
      font-size: 14px;
    }
  }
</style>

<script>
  // å®¢æˆ·ç«¯æŒ‚è½½æ—¶åˆå§‹åŒ–Three.jsåœºæ™¯
  const initScene = async () => {
    // åŠ¨æ€å¯¼å…¥Three.jsä»¥å‡å°‘åˆå§‹åŒ…å¤§å°
    const THREE = await import('three');
    
    // åˆ›å»ºåœºæ™¯
    const scene = new THREE.Scene();
    
    // åˆ›å»ºç›¸æœº
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;
    
    // åˆ›å»ºæ¸²æŸ“å™¨
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x1a1a1a); // è®¾ç½®èƒŒæ™¯è‰²ä¸ºæ·±ç°è‰²
    
    // å¯ç”¨æ¸²æŸ“å™¨çš„äº¤äº’åŠŸèƒ½
    renderer.domElement.style.touchAction = 'none';
    
    // é…ç½®æ¸²æŸ“å™¨ä»¥æé«˜æ¸²æŸ“è´¨é‡
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.6; // é™ä½æ›å…‰åº¦å€¼ï¼Œè®©HDRç¯å¢ƒè´´å›¾ä¸è¿‡æ›
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    
    // å°†æ¸²æŸ“å™¨æ·»åŠ åˆ°é¡µé¢
    document.getElementById('torus-container').appendChild(renderer.domElement);
    
    // æè´¨é…ç½®
    const materials = {
      chrome: new THREE.MeshStandardMaterial({ 
        roughness: 0.1,
        metalness: 0.9,
        color: 0xE8E8E8
      }),
      gold: new THREE.MeshStandardMaterial({ 
        roughness: 0.2,
        metalness: 0.8,
        color: 0xFFD700
      }),
      copper: new THREE.MeshStandardMaterial({ 
        roughness: 0.3,
        metalness: 0.7,
        color: 0xB87333
      }),
      emerald: new THREE.MeshStandardMaterial({ 
        roughness: 0.1,
        metalness: 0.3,
        color: 0x50C878
      }),
      ruby: new THREE.MeshStandardMaterial({ 
        roughness: 0.1,
        metalness: 0.3,
        color: 0xE0115F
      }),
      sapphire: new THREE.MeshStandardMaterial({ 
        roughness: 0.1,
        metalness: 0.3,
        color: 0x0F52BA
      })
    };
    
    // å½“å‰çŠ¶æ€
    let currentMesh = null;
    let currentModel = 'torus';
    let currentMaterial = 'chrome';
    
    // åˆ›å»ºä¸åŒçš„å‡ ä½•æ¨¡å‹
    const createGeometry = (type) => {
      switch(type) {
        case 'torus':
          return new THREE.TorusGeometry(1, 0.4, 16, 100);
        case 'sphere':
          return new THREE.SphereGeometry(1, 32, 32);
        case 'cube':
          return new THREE.BoxGeometry(1.5, 1.5, 1.5);
        case 'cone':
          return new THREE.ConeGeometry(1, 2, 32);
        case 'cylinder':
          return new THREE.CylinderGeometry(1, 1, 2, 32);
        default:
          return new THREE.TorusGeometry(1, 0.4, 16, 100);
      }
    };
    
    // æ›´æ–°æ¨¡å‹å’Œæè´¨
    const updateModel = () => {
      if (currentMesh) {
        scene.remove(currentMesh);
        currentMesh.geometry.dispose();
      }
      
      const geometry = createGeometry(currentModel);
      currentMesh = new THREE.Mesh(geometry, materials[currentMaterial]);
      scene.add(currentMesh);
    };
    
    // åˆ‡æ¢æ¨¡å‹
    const switchModel = (modelType) => {
      currentModel = modelType;
      updateModel();
      
      // æ›´æ–°æŒ‰é’®çŠ¶æ€
      document.querySelectorAll('[data-model]').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-model="${modelType}"]`).classList.add('active');
    };
    
    // åˆ‡æ¢æè´¨
    const switchMaterial = (materialType) => {
      currentMaterial = materialType;
      updateModel();
      
      // æ›´æ–°æŒ‰é’®çŠ¶æ€
      document.querySelectorAll('[data-material]').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-material="${materialType}"]`).classList.add('active');
    };
    
    // èœå•æŠ˜å åŠŸèƒ½
    const initMenuToggle = () => {
      document.querySelectorAll('.menu-header').forEach(header => {
        header.addEventListener('click', () => {
          const menuType = header.getAttribute('data-menu');
          const content = header.nextElementSibling;
          const toggle = header.querySelector('.menu-toggle');
          
          // åˆ‡æ¢æŠ˜å çŠ¶æ€
          if (content.classList.contains('expanded')) {
            content.classList.remove('expanded');
            toggle.textContent = 'â–¼';
            toggle.style.transform = 'rotate(0deg)';
          } else {
            content.classList.add('expanded');
            toggle.textContent = 'â–²';
            toggle.style.transform = 'rotate(180deg)';
          }
        });
      });
    };
    
    // åˆ›å»ºæ°´é¢
    const waterGeometry = new THREE.PlaneGeometry(1000, 1000);
    
    // å¯¼å…¥Waterç±»
    const { Water } = await import('three/examples/jsm/objects/Water.js');
    
    // åˆ›å»ºæ°´é¢å¯¹è±¡
    const water = new Water(
      waterGeometry,
      {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: new THREE.TextureLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/waternormals.jpg', function(texture) {
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        }),
        sunDirection: new THREE.Vector3(),
        sunColor: 0xffffff,
        waterColor: 0x001e0f,
        distortionScale: 1.7,
        fog: scene.fog !== undefined
      }
    );
    
    // è°ƒæ•´æ°´é¢ä½ç½®å’Œæ—‹è½¬
    water.rotation.x = -Math.PI / 2;
    water.position.y = -3;
    scene.add(water);
    
    // å¯¼å…¥OrbitControls
    const { OrbitControls } = await import('three/examples/jsm/controls/OrbitControls.js');
    
    // åŠ è½½HDRç¯å¢ƒè´´å›¾
    const { RGBELoader } = await import('three/examples/jsm/loaders/RGBELoader.js');
    const rgbeLoader = new RGBELoader();
    
    // è®¾ç½®HDRè´´å›¾è·¯å¾„
    const hdrTexture = await rgbeLoader.loadAsync('/threejs-learn/hdr/default.hdr');
    hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
    
    // é…ç½®æ¸²æŸ“å™¨çš„è‰²è°ƒæ˜ å°„ä»¥ä¿®æ­£æ›å…‰åº¦
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.6; // é™ä½æ›å…‰åº¦å€¼ï¼Œè®©HDRç¯å¢ƒè´´å›¾ä¸è¿‡æ›
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    
    // å°†HDRè´´å›¾è®¾ç½®ä¸ºåœºæ™¯ç¯å¢ƒè´´å›¾
    scene.environment = hdrTexture;
    scene.background = hdrTexture;
    
    // åˆ›å»ºæ§åˆ¶å™¨
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // å¯ç”¨é˜»å°¼æ•ˆæœ
    controls.dampingFactor = 0.05; // é˜»å°¼ç³»æ•°
    controls.screenSpacePanning = false; // ç¦ç”¨å±å¹•ç©ºé—´å¹³ç§»
    controls.minDistance = 1; // æœ€å°ç¼©æ”¾è·ç¦»
    controls.maxDistance = 50; // æœ€å¤§ç¼©æ”¾è·ç¦»
    
    // æ°´é¢åŠ¨ç”»é€Ÿåº¦æ§åˆ¶
    const waterAnimationSpeed = 0.2; // è°ƒæ•´è¿™ä¸ªå€¼æ¥æ§åˆ¶æ°´é¢åŠ¨ç”»é€Ÿåº¦ï¼Œ1.0ä¸ºé»˜è®¤é€Ÿåº¦
    
    // åˆå§‹åŒ–åœºæ™¯
    updateModel();
    initMenuToggle();
    
    // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
    document.querySelectorAll('[data-model]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const modelType = e.target.getAttribute('data-model');
        switchModel(modelType);
      });
    });
    
    document.querySelectorAll('[data-material]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const materialType = e.target.getAttribute('data-material');
        switchMaterial(materialType);
      });
    });
    
    // åŠ¨ç”»å‡½æ•°
    const animate = () => {
      requestAnimationFrame(animate);
      
      // æ›´æ–°æ§åˆ¶å™¨
      controls.update();
      
      // ä½¿å½“å‰æ¨¡å‹æ²¿Yè½´ç¼“æ…¢æ—‹è½¬
      if (currentMesh) {
        currentMesh.rotation.y += 0.005;
      }
      
      // æ›´æ–°æ°´é¢åŠ¨ç”»
      water.material.uniforms["time"].value += (1.0 / 60.0) * waterAnimationSpeed;
      
      // æ¸²æŸ“åœºæ™¯
      renderer.render(scene, camera);
    };
    
    // å¯åŠ¨åŠ¨ç”»
    animate();
    
    // å¤„ç†çª—å£å¤§å°è°ƒæ•´
    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    
    window.addEventListener('resize', handleResize);
    
    // ç»„ä»¶å¸è½½æ—¶æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
    return () => {
      window.removeEventListener('resize', handleResize);
      controls.dispose(); // æ¸…ç†æ§åˆ¶å™¨
      
      // æ¸…ç†æ‰€æœ‰æè´¨
      Object.values(materials).forEach(material => material.dispose());
    };
  };
  
  // ç»„ä»¶åŠ è½½æ—¶åˆå§‹åŒ–åœºæ™¯
  initScene();
</script>